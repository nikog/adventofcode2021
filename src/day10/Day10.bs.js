// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Solution = require("../Solution.bs.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var Belt_SortArray = require("rescript/lib/js/belt_SortArray.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

var $$SyntaxError = /* @__PURE__ */Caml_exceptions.create("Day10.SyntaxError");

var ActualError = /* @__PURE__ */Caml_exceptions.create("Day10.ActualError");

function scores($$char) {
  switch ($$char) {
    case ")" :
        return 3;
    case ">" :
        return 25137;
    case "]" :
        return 57;
    case "}" :
        return 1197;
    default:
      return 0;
  }
}

function opposite($$char) {
  switch ($$char) {
    case "(" :
        return ")";
    case "<" :
        return ">";
    case "[" :
        return "]";
    case "{" :
        return "}";
    default:
      throw {
            RE_EXN_ID: ActualError,
            Error: new Error()
          };
  }
}

function parse(_line, stack) {
  while(true) {
    var line = _line;
    var $$char = line.charAt(0);
    var nextLine = line.slice(1);
    switch ($$char) {
      case "" :
          return ;
      case "(" :
      case "<" :
      case "[" :
      case "{" :
          break;
      default:
        if ($$char === opposite(Caml_array.get(stack, stack.length - 1 | 0))) {
          stack.pop();
          _line = nextLine;
          continue ;
        }
        throw {
              RE_EXN_ID: $$SyntaxError,
              _1: scores($$char),
              Error: new Error()
            };
    }
    stack.push($$char);
    _line = nextLine;
    continue ;
  };
}

function make(input) {
  return input.split("\n").reduce((function (acc, line) {
                try {
                  parse(line, []);
                  return acc;
                }
                catch (raw_score){
                  var score = Caml_js_exceptions.internalToOCamlException(raw_score);
                  if (score.RE_EXN_ID === $$SyntaxError) {
                    return acc + score._1 | 0;
                  }
                  throw score;
                }
              }), 0);
}

var Part01 = {
  scores: scores,
  opposite: opposite,
  parse: parse,
  make: make
};

function scores$1($$char) {
  switch ($$char) {
    case ")" :
        return 1;
    case ">" :
        return 4;
    case "]" :
        return 2;
    case "}" :
        return 3;
    default:
      return 0;
  }
}

function opposite$1($$char) {
  switch ($$char) {
    case "(" :
        return ")";
    case "<" :
        return ">";
    case "[" :
        return "]";
    case "{" :
        return "}";
    default:
      throw {
            RE_EXN_ID: ActualError,
            Error: new Error()
          };
  }
}

function getMiddle(arr) {
  return arr[arr.length / 2 | 0];
}

function tap(arr) {
  console.log(arr);
  return arr;
}

function parse$1(_line, stack) {
  while(true) {
    var line = _line;
    var $$char = line.charAt(0);
    var nextLine = line.slice(1);
    switch ($$char) {
      case "" :
          return stack;
      case "(" :
      case "<" :
      case "[" :
      case "{" :
          break;
      default:
        if ($$char === opposite$1(Caml_array.get(stack, stack.length - 1 | 0))) {
          stack.pop();
          _line = nextLine;
          continue ;
        }
        throw {
              RE_EXN_ID: $$SyntaxError,
              _1: scores$1($$char),
              Error: new Error()
            };
    }
    stack.push($$char);
    _line = nextLine;
    continue ;
  };
}

function autocompleteScore(prev, $$char) {
  var score = scores$1(opposite$1($$char));
  return prev * 5 + score;
}

function getAutoCompleteScore(scores, line) {
  try {
    var stack = parse$1(line, []);
    var score = stack.reduceRight(autocompleteScore, 0);
    scores.push(score);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID !== $$SyntaxError) {
      throw exn;
    }
    
  }
  return scores;
}

function make$1(input) {
  return getMiddle(Belt_SortArray.stableSortBy(input.split("\n").reduce(getAutoCompleteScore, []), (function (a, b) {
                    if (a > b) {
                      return 1;
                    } else {
                      return -1;
                    }
                  })));
}

var Part02 = {
  scores: scores$1,
  opposite: opposite$1,
  getMiddle: getMiddle,
  tap: tap,
  parse: parse$1,
  autocompleteScore: autocompleteScore,
  getAutoCompleteScore: getAutoCompleteScore,
  make: make$1
};

Solution.make(make, "day10/input");

Solution.make(make$1, "day10/input");

exports.$$SyntaxError = $$SyntaxError;
exports.ActualError = ActualError;
exports.Part01 = Part01;
exports.Part02 = Part02;
/*  Not a pure module */
