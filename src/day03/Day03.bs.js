// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Solution = require("../Solution.bs.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var Pervasives = require("rescript/lib/js/pervasives.js");
var Caml_format = require("rescript/lib/js/caml_format.js");

function toBinary(binaryString) {
  return Caml_format.caml_int_of_string("0b" + binaryString);
}

var binaryNot = Pervasives.lnot;

function binaryToDecimal(binary) {
  return Belt_Int.fromString(binary.toString(10));
}

function significantBits(flagOpt, lines) {
  var flag = flagOpt !== undefined ? flagOpt : false;
  var initial1 = Belt_Array.makeBy(Caml_array.get(lines, 0).length, (function (param) {
          return 0;
        }));
  var initial0 = Belt_Array.makeBy(Caml_array.get(lines, 0).length, (function (param) {
          return 0;
        }));
  var match = lines.reduce((function (param, binary) {
          var bit0 = param[1];
          var bit1 = param[0];
          var bits = binary.split("");
          bits.forEach(function (bit, i) {
                if (bit === "1") {
                  return Caml_array.set(bit1, i, Caml_array.get(bit1, i) + 1 | 0);
                } else {
                  return Caml_array.set(bit0, i, Caml_array.get(bit0, i) + 1 | 0);
                }
              });
          return [
                  bit1,
                  bit0
                ];
        }), [
        initial1,
        initial0
      ]);
  var bit0 = match[1];
  var bit1 = match[0];
  if (flag) {
    return initial1.map(function (param, i) {
                  if (Caml_array.get(bit1, i) >= Caml_array.get(bit0, i)) {
                    return 0;
                  } else {
                    return 1;
                  }
                }).join("");
  } else {
    return initial1.map(function (param, i) {
                  if (Caml_array.get(bit1, i) >= Caml_array.get(bit0, i)) {
                    return 1;
                  } else {
                    return 0;
                  }
                }).join("");
  }
}

function make(input) {
  var lines = input.split("\n");
  var mostSignificant = significantBits(undefined, lines);
  var leastSignificant = mostSignificant.split("").map(function (bit) {
          if (bit === "1") {
            return "0";
          } else {
            return "1";
          }
        }).join("");
  var binary = Caml_format.caml_int_of_string("0b" + mostSignificant);
  var gamma = Belt_Int.fromString(binary.toString(10));
  var binary$1 = Caml_format.caml_int_of_string("0b" + leastSignificant);
  var epsilon = Belt_Int.fromString(binary$1.toString(10));
  if (gamma !== undefined && epsilon !== undefined) {
    return Math.imul(gamma, epsilon);
  } else {
    return 0;
  }
}

var Part01 = {
  make: make
};

function findOxygenOrCo2Rating(_lines, _mostSignificant, _i, flag) {
  while(true) {
    var i = _i;
    var mostSignificant = _mostSignificant;
    var lines = _lines;
    var bit = Caml_array.get(mostSignificant, i);
    var lines$1 = lines.filter((function(i,bit){
        return function (line) {
          var splitLine = line.split("");
          return Caml_array.get(splitLine, i) === bit;
        }
        }(i,bit)));
    if (lines$1.length === 1) {
      return Caml_array.get(lines$1, 0);
    }
    _i = i + 1 | 0;
    _mostSignificant = significantBits(flag, lines$1).split("");
    _lines = lines$1;
    continue ;
  };
}

function make$1(input) {
  var lines = input.split("\n");
  var mostSignificant = significantBits(undefined, lines).split("");
  var least = significantBits(true, lines).split("");
  var binaryString = findOxygenOrCo2Rating(lines, mostSignificant, 0, false);
  var binary = Caml_format.caml_int_of_string("0b" + binaryString);
  var oxygen = Belt_Int.fromString(binary.toString(10));
  var binaryString$1 = findOxygenOrCo2Rating(lines, least, 0, true);
  var binary$1 = Caml_format.caml_int_of_string("0b" + binaryString$1);
  var co2 = Belt_Int.fromString(binary$1.toString(10));
  if (oxygen !== undefined && co2 !== undefined) {
    return Math.imul(oxygen, co2);
  } else {
    return 0;
  }
}

var Part02 = {
  make: make$1
};

Solution.make(make, "day03/input");

exports.toBinary = toBinary;
exports.binaryNot = binaryNot;
exports.binaryToDecimal = binaryToDecimal;
exports.significantBits = significantBits;
exports.Part01 = Part01;
exports.findOxygenOrCo2Rating = findOxygenOrCo2Rating;
exports.Part02 = Part02;
/*  Not a pure module */
